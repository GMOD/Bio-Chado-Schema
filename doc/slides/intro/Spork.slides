----
presentation_topic: dbic_chado
presentation_title: Bio::Chado::Schema, a standard ORM layer for Chado
presentation_place: San Diego, CA
presentation_date: January 13-14, 2010
----
= What is DBIx::Class?

* Object-relational mapping framework for Perl
* is now the de-facto standard
* very powerful features for:
+** query building (the magic of chainable ResultSets)
+** cross-database deployment (using |SQL::Translator| in the backend)
+** testing with Fixtures

see http://search.cpan.org/dist/DBIx-Class/lib/DBIx/Class/Manual.pod

----
= Data Model

* a set of classes
* encapsulate the underlying storage
* providing a nice(r) API for working with the data

== This isn't really middleware, as the term is usually used.

----
= Chado needs encapsulation

== Chado's design makes for:
* complex queries
* steep learning curve
* hard to get good performance

----
= Chado needs encapsulation

== Data model classes can help with:
* complex queries
+** storing, automating, and/or facilitating them
+* steep learning curve
+** codifying best practices
** unified, high-level documentation
** can help with database administration
+* hard to get good performance
+** encapsulation => performance optimizations where needed
** helps create indexes and materialized views

----
= What is BCS

== Approx. 180 Perl classes that mirror the Chado schema
+* covers all tables in all modules
+* includes full POD extracted from Chado itself

http://search.cpan.org/dist/Bio-Chado-Schema

----
= BCS Usage: Selecting

* open the schema, lazily connecting
  my $chado = Bio::Chado::Schema->connect( 'dbi:Pg:...', $user, $pass );

+* get a ResultSet object representing a set of Rows
  my $all_features = $chado->resultset('Sequence::Feature');

+* a subset of those (another ResultSet)
  my $other_feature = $all_features->search({ name => 'something' });

+* get a Row
  my $some_feature = $all_features->find( 232432 );

+* get its type cvterm
  say $some_feature->type->name;

----
= BCS Usage: Joined Select

  my $potato_bacs =
       $chado->resultset('Organism::Organism')
             ->search({ species => 'Solanum tuberosum' })
             ->search_related( 'features',
                               { 'type.name' => 'BAC_clone'},
                               { 'join' => 'type' },
                             );

----
= BCS Usage: Joined Select

  my $potato_bacs = $dbh->selectall_arrayref( <<EOS, undef, 'Solanum tuberosum', 'BAC_clone');
  SELECT features.feature_id
       , features.dbxref_id
       , features.organism_id
       , features.name
       , features.uniquename
       , features.residues
       , features.seqlen
       , features.md5checksum
       , features.type_id
       , features.is_analysis
       , features.is_obsolete
       , features.timeaccessioned
       , features.timelastmodified
  FROM organism me
  LEFT JOIN feature features
         ON features.organism_id = me.organism_id
  JOIN cvterm type
         ON type.cvterm_id = features.type_id
  WHERE type.name = 'BAC_clone' AND species = 'Solanum tuberosum'
  EOS

----
= BCS Usage: Loading

  $chado->resultset( 'Cv::Cv' )
        ->find_or_create({ name => 'My Fake Ontology' })
        ->create_related(  'cvterm',
                           { name => 'MyFakeTerm' });

maps to

  SELECT me.cv_id
       , me.name
       , me.definition
  FROM cv me
  WHERE ( me.name = 'my fake ontology' )

  INSERT INTO cv ( name )
          VALUES ( ?    )


----
= BCS Usage: Transactions

  $chado->txn_do(sub {
      $chado->resultset('Cv::Cv')
            ->find_or_create({ name => 'My Fake Ontology' })
            ->create_related( 'cvterm', { name => 'MyFakeTerm' } );
  });

----
= Using DBIC with your own tables

* use DBIx::Class::Schema::Loader to dump a whole set
* make your own definitions

  package My::DBIC:::Layer::OtherThing;
  use base 'DBIx::Class::Core';

  __PACKAGE__->table('other_thing');
  __PACKAGE__->add_columns(
    'other_thing_id' => { ... },
    'name'           => { ... },
    'definition'     => { ... },
    'feature_id'     => { ... },
  );
  __PACKAGE__->set_primary_key('other_thing_id');
  __PACKAGE__->add_unique_constraint('ot_c1', ['name']);

  __PACKAGE__->belongs_to(
    'feature',
    'Bio::Chado::Schema::Sequence::Feature',
    { 'foreign.feature_id' => 'self.feature_id' },
  );

----
= "Duct tape" BCS to your own schema

* make an accessor 'other_things' that ties your own DBIC class to BCS

  Bio::Chado::Schema::Sequence::Feature->has_many(
    'other_things',
    'My::DBIC::Layer::OtherThing',
    { 'foreign.feature_id' => 'self.feature_id' },
  );

* add it to the BCS schema dynamically
  Bio::Chado::Schema->register_source('OtherThing', 'My::DBIC::Layer::OtherThing');

* use it with the rest
  $chado->resultset('Sequence::Feature')->other_things;

----
= Making a composite schema

  my $merged_schema_class =
        Bio::Chado::Schema->merge( 'My::DBIC::Layer' );

  $merged_schema_class->connect( ... );

  $chado->resultset('Sequence::Feature')->other_things;
	
----
= Further Work

== Still need to add in some DBIx::Class relationships:
* more many_to_many relationships (must be added manually)
== More useful things are needed:
* automate more common querying and loading patterns
* compatibility with BioPerl data objects

----
== Acknowledgments

* Aure Bombarely (SGN)
* Naama Menda (SGN)
* Siddhartha Basu (dictybase)
* Lukas Mueller (SGN)

----
== That's All

* The END
